<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Google Analytics -->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-36064200-2', 'auto');
  ga('send', 'pageview');

  </script>

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      WxWidgets Tutorial &middot; Awesome Programmer
    
  </title>

  <meta name="description" content="wxWidgets is a cross-platform C++ GUI toolkit which provides  an easy and fast way to implement GUI of any complexity. In this tutorial we will compile wxWidgets under Linux and write simple GUI application."/>
  <meta name="keywords" content="c++, GUI, wxWidgets"/>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Awesome Programmer" href="/atom.xml">
</head>


  <body class="sidebar-overlay theme-base-0c">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-avatar">
     <img src="/public/avatar.png">
  </div>
  <div class="sidebar-item">
    <p>The diary of awesome programmer and cool guy.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
    
      
        
      
    
      
        
      
    
    <a class="sidebar-nav-item" href="https://github.com/RostakaGmfun/rostakagmfun.github.io">GitHub project</a>
  </nav>
  <div class ="sidebar-item">
          <a href="https://github.com/RostakaGmfun" target="_blank"><img src="/public/gh-mark.png"></a>GitHub
  </div>
  <div class ="sidebar-item">
          <a href="https://twitter.com/RostakaGmfun" target="_blank"><img src="/public/twitter512.png" width=36 height=36 ></a>Twitter
  </div>
  <div class="sidebar-item">
    <p>
      &copy; 2014-2015. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Awesome Programmer</a>
            <small>RostakaGmfun's blog</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <article class="post">
  <h1 class="post-title">WxWidgets Tutorial</h1>
  <time datetime="2014-02-17T00:00:00+02:00" class="page-date">17 Feb 2014</time>
  <h2 id='introduction'>Introduction</h2>

<p><em>wxWidgets</em> is a cross-platform C++ GUI toolkit which provides an easy and fast way to implement GUI of any complexity. In this tutorial we will compile <em>wxWidgets</em> under Linux and write simple GUI application.</p>

<h2 id='compiling_wxwidgets'>Compiling wxWidgets</h2>

<p>First, make sure you have GTK development files: <div>
  <pre><code class='bash'>$sudo apt-get install libgtk2.0-dev</code></pre>
</div></p>

<p>Next, download wxGTK source and extract the files somewere. After you have extracted the files:</p>
<div>
  <pre><code class='bash'>$cd path/to/wxGTK
$mkdir build-gtk
$cd build-gtk</code></pre>
</div>
<p>We have created the build directory from where we will build wxWidgets binaries. Next, type this to configure:</p>
<div>
  <pre><code class='bash'>$../configure</code></pre>
</div>
<p>And then: <div>
  <pre><code class='bash'>$make</code></pre>
</div></p>

<p>After the compilation you can install wxWidgets with:</p>
<div>
  <pre><code class='bash'>$make install</code></pre>
</div>
<p>Writing a simple demo</p>

<p>Our next step is to write simple demo to demonstrate the power of wxWidgets library. We wll create a window with toolbar, menu and a few tabs with different things inside. I will guide you step by step and eventually you can grab the source code for this tutorial from it<code>s Github [repository](https://github.com/RostakaGmfun/wxWidgetsTutorial).</code></p>

<h2 id='creating_an_application_and_window'>Creating an application and window</h2>

<p>Every wxWidgets application is represented as a class derived from <code>wxApp</code>. So we will declare our <code>App</code> class derived from <code>wxApp</code> in <code>app.h</code> file:</p>
<div>
  <pre><code class='cpp'>#include &lt;wx/app.h&gt;

    class App : public wxApp
    {
        public:
            virtual bool OnInit();
    };</code></pre>
</div>
<p>Here we declare a single method OnInit() which will be called once our application starts. In this method we will create our window. The actual application entry point and implementation is defined as <code>IMPLEMENT_APP</code> macro which we place in our <code>app.cpp</code> file: <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&apos;cpp&apos;&gt;#include &amp;quot;app.h&amp;quot;</pre></p>

<p>IMPLEMENT_APP(App);&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;</p>

<p>Our App::OnInit() is empty for now: <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&apos;cpp&apos;&gt;bool App::OnInit()
{</pre></p>

<pre><code>return true;</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;</p>

<p>Now it is time to create the window. Our window class is called Frame and is derived from wxFrame. I placed Frame declaration and definition in main.h and main.cpp respectively. I called those two files as main because the main code is here.</p>
<div>
  <pre><code class='cpp'>#include &lt;wx/wx.h&gt;

class Frame: public wxFrame //our Frame class derives from wxFrame base class
{
    public:
        Frame(wxFrame *frame, const wxString&amp; title);
        ~Frame();</code></pre>
</div>
<p>We have an constructor which takes as parameters a pointer to the parent window(if any) and a title string. Next look at the constructor definition:</p>
<div>
  <pre><code class='cpp'>Frame::Frame(wxFrame *frame, const wxString&amp; title) //in our constructor we call wxFrame constructor to create a window
    : wxFrame(frame, -1, title, wxPoint(100,100),wxDefaultSize,wxMINIMIZE_BOX | wxSYSTEM_MENU | wxCAPTION | wxCLOSE_BOX)
{
    SetSize(1024,768); //set the size
}</code></pre>
</div>
<p>In our constructor we call <code>wxFrame</code> constructor to actually create the window at screen coordinates <code>(100;100)</code>. We also call <code>wxFrame</code> member function <code>SetSize()</code> to set the window size (you also can specify window size in constructor by writing <code>wxPoint(1024,768)</code> instead of <code>wxDefaultSize</code>). To show our window we should include <code>main.h</code> file in <code>app.cpp</code> and modify our <code>App::OnInit()</code> function:</p>
<div>
  <pre><code class='cpp'>bool App::OnInit()
{
    Frame* frame = new Frame(0L, &quot;Awesome Programmer wxWidgets Tutorial&quot;);

    frame-&gt;Show();

    return true;
}</code></pre>
</div>
<p>We call wxFrame::Show() to show our window.</p>

<h2 id='adding_menu_and_toolbar'>Adding menu and toolbar</h2>

<p>It is time to add menu to our window. In <code>main.h</code>:</p>
<div>
  <pre><code class='cpp'>class Frame: public wxFrame
{
    private:
        wxMenuBar* menuBar;
 wxMenu* menuFile;
 wxMenu* menuAbout;
}</code></pre>
</div>
<p>And in <code>main.cpp</code>:</p>
<div>
  <pre><code class='cpp'>Frame::Frame(wxFrame *frame, const wxString&amp; title)
    : wxFrame(frame, -1, title, wxPoint(100,100),wxDefaultSize,wxMINIMIZE_BOX | wxSYSTEM_MENU | wxCAPTION | wxCLOSE_BOX)
{
       SetSize(1024,768); //set the size
       menuBar = new wxMenuBar;
       menuFile = new wxMenu;
       menuAbout = new wxMenu;
       menuPaint = new wxMenu;

       //append menu entries for our 'File' and 'About' menus
       //we use the same event IDs as in EVT_MENU macro (see above)
       menuFile-&gt;Append(NEW,&quot;&amp;New&quot;);
       menuFile-&gt;Append(OPEN,&quot;&amp;Open&quot;);
       menuFile-&gt;Append(SAVE,&quot;&amp;Save&quot;);
       menuFile-&gt;Append(QUIT,&quot;&amp;Quit&quot;);

      menuAbout-&gt;Append(ABOUT,&quot;&amp;About&quot;);

 //append menus to the menubar
 menuBar-&gt;Append(menuFile,&quot;&amp;File&quot;);
 menuBar-&gt;Append(menuAbout,&quot;&amp;Help&quot;);

 //show our menu bar
 SetMenuBar(menuBar);
}</code></pre>
</div>
<p>A little explanation is needed here. First, we create our objects. The we use <code>wxMenu::Append()</code> function to add menu entry. <code>wxMenu::Append()</code> function takes as parameter an <code>ID</code> of event to be handled when the users selects that entry(see below) and a text to display. Finally we append our menus to the menu bar with <code>wxMenuBar::Append()</code> function and set up the menu bar for our window with <code>SetMenuBar() function.</code></p>

<p>And now let&#8217;s add some response to our menu. First of all, place a call to <code>DECLARE_EVENT_TABLE()</code> macro in our <code>Frame</code> class definition. We will define so-called event table later. We will specify the event handler - the callback function which will be called on particular event. First, we will create an event handler for <code>About</code> menu. So place the following private function declaration in our <code>Frame</code> class:</p>

<pre><code>void OnAbout(wxCommandEvent&amp; event);</code></pre>

<p>Next, add function&#8217;s definition in <code>main.cpp</code>:</p>
<div>
  <pre><code class='cpp'>void Frame::OnAbout(wxCommandEvent &amp;event)
{
    wxMessageBox(&quot;This is simple wxWidgets tutorial from awesomeproger.blogspot.com&quot;, &quot;Awesome Programmer tutorial&quot;);
}</code></pre>
</div>
<p>Every event handler in wxWidgets must have it&#8217;s own <code>ID</code>. It is possible to use predefined <code>ID</code>s, but we will declare our own as enumeration:</p>
<div>
  <pre><code class='cpp'>enum ev_ids
{
    QUIT,
    ABOUT,
    OPEN,
    SAVE,
    NEW,
};</code></pre>
</div>
<p>We will add more IDs later to have more functionality. To actually specify this function as event handler we need to add the following code somewhere in <code>main.cpp</code>:</p>
<div>
  <pre><code class='cpp'>BEGIN_EVENT_TABLE(Frame, wxFrame) //we begin declaring event table by specifying the class we want to declare event table for and it's base class
    //we use EVT_MENU macro for menu entries. Here we pas a custom defined event id which we will use later to create appropriate controls
    EVT_MENU(ABOUT, Frame::OnAbout)
END_EVENT_TABLE()</code></pre>
</div>
<p><code>EVT_MENU</code> macro specifies a menu event. It takes as parameters and event <code>ID</code> and an event handler function.</p>

<p>Next, try adding a <code>QUIT</code> event, use <code>Close()</code> function to close the window.</p>

<p>Now it is time to create a toolbar which will duplicate the functionality of menu bar. Add a private pointer to <code>wxToolBar</code> in our <code>Frame</code> class and use the following code to create toolbar:</p>
<div>
  <pre><code class='cpp'>toolBar = CreateToolBar();

    //we use wxArtProvider class (from wx/artprov.h) to get the default icons into our bitmaps
    wxBitmap open = wxArtProvider::GetBitmap(wxART_FILE_OPEN,wxART_TOOLBAR);
    wxBitmap exit = wxArtProvider::GetBitmap(wxART_QUIT,wxART_TOOLBAR);
    wxBitmap save = wxArtProvider::GetBitmap(wxART_FILE_SAVE, wxART_TOOLBAR);
    wxBitmap b_new = wxArtProvider::GetBitmap(wxART_NEW,wxART_TOOLBAR);

    toolBar-&gt;AddTool(NEW, b_new, &quot;New file&quot;);
    toolBar-&gt;AddTool(OPEN, open, &quot;Open file&quot;);
    toolBar-&gt;AddTool(SAVE, save, &quot;Save file&quot;);
    toolBar-&gt;AddTool(QUIT, exit, &quot;Exit&quot;);

    //show our toolbar. It needs to be called every time the toolbar has been modified
    toolBar-&gt;Realize();</code></pre>
</div>
<p>We used function <code>CreateToolBar()</code> to create toolbar and <code>wxToolBar::AddTool()</code> to add buttons to it. The <code>AddTool()</code> functions takes as parameters corresponding event <code>ID</code>, bitmap image for the button(see below) and a text to display when the mouse hovers on button. To create bitmaps for our images we used <code>wxArtProviderClass</code> instead of manually loading custom images from disk. The <code>wxArtProvider::GetBitmap()</code> returns the <code>wxBitmap</code> for us. There is a number of predefined values for first parameter of the function and the second parameter tells that we want toolbar bitmap. The complete list of bitmap IDs can be found in <code>wxWidgets</code> <a href='http://docs.wxwidgets.org/trunk/classwx_art_provider.html'>documentation</a>. Finally, the <code>wxToolBar::Realize()</code> functions shows our toolbar to the user.</p>

<h2 id='creating_multiple_tabs'>Creating multiple tabs</h2>

<p>It is time to create tabs and add interesting things to them. First, we will make a tab with <code>wxTreeCtrl</code> demo. <code>wxTreeCtrl</code> control allows to add tree view and represent hierarchical information. Add a private pointers to <code>wxNotebook</code> and <code>wxTreeCtrl</code> in our <code>Frame</code> class and use the following code in our <code>Frame</code> constructor:</p>
<div>
  <pre><code class='cpp'>notebook = new wxNotebook(this,wxID_ANY);

 tree = new wxTreeCtrl(notebook,wxID_ANY);
 notebook-&gt;AddPage(tree,&quot;Tree example&quot;);
 tree-&gt;SetBackgroundColour(wxColour(240,240,240));</code></pre>
</div>
<p>Here we create the <code>wxNotebook</code> object as a child for our Frame and a <code>wxTreeCtrl</code> object as a child of <code>wxNotebook</code>. Next, we add a page containing our tree object to the notebook with the function <code>wxNotebook::AddPage()</code>. We also set the background color to very light for tree object. You can use <code>SetBackgroundColour()</code> method for any window type. Next I will demonstrate the usage of <code>wxTreeCtrl</code>:</p>
<div>
  <pre><code class='cpp'>tree-&gt;SetWindowStyle(wxTR_HIDE_ROOT); //hides the real root node to have many roots
    wxTreeItemId root = tree-&gt;AddRoot(&quot;invisible root&quot;);//this root will be invisible
    wxTreeItemId r1 = tree-&gt;AppendItem(root, &quot;Root1&quot;);
    wxTreeItemId r2 = tree-&gt;AppendItem(root,&quot;Root2&quot;);
    tree-&gt;AppendItem(r1,&quot;Node1&quot;);
    tree-&gt;AppendItem(r1,&quot;Node2&quot;);
    tree-&gt;AppendItem(r2,&quot;Node3&quot;);</code></pre>
</div>
<p>The <code>wxTR_HIDE_ROOT</code> style flag hides the real root of tree. We need this in order to have many independent roots (which actually are nodes of hidden root). Every node in <code>wxTreeCtrl</code> is of type <code>wxTreeItemId</code>. We first add invisible root and the use the returned element <code>ID</code> to append childs to it with a help of function <code>wxTreeCtrl::AppendItem()</code>. Now we are going to implement the event for node selection. Add function prototype in our <code>Frame</code> class:</p>

<pre><code>void OnTreeItemSelected(wxTreeEvent&amp; event);</code></pre>

<p>The definition: <div>
  <pre><code class='cpp'>void Frame::OnTreeItemSelected(wxTreeEvent&amp; event)
{
    wxTreeItemId selectedItem = event.GetItem();
    if(!tree-&gt;ItemHasChildren(selectedItem)) //report only if node was selected
        wxMessageBox(&quot;Selected node name: &quot;+tree-&gt;GetItemText(selectedItem), &quot;Node selected!&quot;);
    else
        tree-&gt;Expand(selectedItem); //othervise just expand the item
    return;
}</code></pre>
</div></p>

<p>We use <code>wxTreeEvent</code> object to get the selected item. Next we check whether this item has no child nodes(so it is node itself) and if so display the message box with the name of the selected node. If one of the roots was selected we expand it to show child nodes. To specify this function as the event handler for tree object, we use the <code>EVT_TREE_ITEM_ACTIVATED</code> macro. We specify <code>wxID_ANY</code> as <code>ID</code> for our event because we have only one tree object.</p>

<p>Well, let&#8217;s add another tab to our window. We will place a code editor there. For full featured text editor with code highlighting the <code>wxStyledTextCtrl</code> is used. This is a wrapper around <code>Scintilla</code> code editing component. Despite the real complexity of code editor, using <code>wxStyledTextCtrl</code> is rather simple and the results are really nice. So include <code>wx/stc/stc.h</code> header file in <code>main.h</code> and add private to <code>wxStyledTextCtrl</code> in <code>private</code> section. Add the following code to <code>Frame</code> constructor: <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&apos;cpp&apos;&gt;//create Scintilla text editor object
    editor = new wxStyledTextCtrl(notebook,wxID_ANY,wxDefaultPosition,this-&amp;gt;GetSize());
    notebook-&amp;gt;AddPage(editor,&amp;quot;Editor&amp;quot;);
 //set our font for the whole text. We should specify this before defining styles for particular things (keywords, numbers, string, etc.)
 wxFont font(12,wxFONTFAMILY_DEFAULT,wxFONTSTYLE_NORMAL,wxFONTWEIGHT_NORMAL);
 editor-&amp;gt;StyleSetFont(wxSTC_STYLE_DEFAULT,font);
    editor-&amp;gt;StyleSetForeground (wxSTC_STYLE_LINENUMBER, wxColour (75, 75, 75) );
    editor-&amp;gt;SetCaretLineVisible(true); //enable current line highlighting
    editor-&amp;gt;SetCaretLineBackground(wxColour(245,245,255)); //very light highliting color for active line
    editor-&amp;gt;StyleSetBackground (wxSTC_STYLE_LINENUMBER, wxColour (220, 220, 220));
    editor-&amp;gt;SetMarginWidth(0,55);
    editor-&amp;gt;SetMarginType (0, wxSTC_MARGIN_NUMBER);
    editor-&amp;gt;StyleClearAll();
    editor-&amp;gt;SetLexer(wxSTC_LEX_CPP);
    editor-&amp;gt;StyleSetForeground (wxSTC_C_STRING,wxColour(150,0,0));
    editor-&amp;gt;StyleSetForeground (wxSTC_C_PREPROCESSOR,wxColour(0,150,105));
    editor-&amp;gt;StyleSetForeground (wxSTC_C_IDENTIFIER,wxColour(0,0,0));
    editor-&amp;gt;StyleSetForeground (wxSTC_C_NUMBER,wxColour(0,150,0));
    editor-&amp;gt;StyleSetForeground (wxSTC_C_CHARACTER,wxColour(150,0,0));
    editor-&amp;gt;StyleSetForeground (wxSTC_C_WORD,wxColour(32,100,200));
    editor-&amp;gt;StyleSetForeground (wxSTC_C_COMMENT,wxColour(150,150,150));
    editor-&amp;gt;StyleSetForeground (wxSTC_C_COMMENTLINE,wxColour(150,150,150));
    editor-&amp;gt;StyleSetBold(wxSTC_C_WORD, true);</pre></p>

<pre><code>//list of c++ 11 keywords from http://en.cppreference.com/w/cpp/keyword</code></pre>

<p>editor-&#62;SetKeyWords(0, wxT( &#34;alignas alignof and and_eq asm auto bitand bitor bool break case catch char char16_t char32_t class compl const constexpr &#34; &#34;const_cast continue decltype default delete do double dynamic_cast else&#34; &#34;enum explicit export extern false float for friend goto if inline int long mutable namespace new noexcept not not_eq nullptr operator or or_eq private protected public register reinterpret_cast&#34; &#34;return short signed sizeof static static_assert static_cast struct switch template this thread_local throw true try typedef typeid typename union unsigned using virtual void volatile wchar_t while xor xor_eq&#34; ));&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;</p>

<p>First we create the editor object and add it as a page to our notebook. Next we specify a global font before setting particular styling for keywords, strings, numbers etc. After that we enable current line highlighting and set the highlight color. We also specify the left margin attributes for line numbers and then begin styling the C++ lexicon. First we choose the lexer as <code>wxSTC_LEX_CPP</code>. There are a number of predefined lexers. To see the corresponding defines look into <code>wx/stc/stc.h</code> file. After that we specify individual colors for strings(enclosed in double quotes), preprocessor, identifiers, numbers, characters (enclosed in a single quotes), keywords, line comments, and multiline comments. We also enable bold font for keywords. What goes next is a list of all C++ 11 keywords for keyword set 0 (that is our <code>wxSTC_C_WORD</code>).</p>

<p>Now lets add an ability to open files. We will define <code>Frame::OnOpen()</code> event handler. Try adding the event handler to the event table on your own. And here is the implementation of <code>Frame::OnOpen()</code> function:</p>
<div>
  <pre><code class='cpp'>void Frame::OnOpen(wxCommandEvent &amp;event)
{
    wxString p = wxFileSelector(&quot;Open file&quot;, &quot;&quot;,
    &quot;&quot;, &quot;&quot;);
 if(p!=wxEmptyString)
 {
        ifstream file(p);
        if(!file.is_open())
        {
            wxMessageBox(&quot;Error opening file&quot;,&quot;Error&quot;);
            return;
        }
        fileName = p;
        //read file contents
        string val, full;
        while(file.good())
        {
            getline(file,val);
            full+=val+&quot;\n&quot;;
        }
        file.close();
        editor-&gt;SetText(full);
        //convert all EOLs to one mode. If you do not understand the reason of this call, comment it out and try out.
        //Some lines will not be detected by Scintilla
        editor-&gt;ConvertEOLs(wxSTC_EOL_LF);

 }
}</code></pre>
</div>
<p>We use <code>wxFileSelector()</code> function to display file selection dialog. The first parameter is dialog name and the other three are default path, default file name, default extension and wildcard, which we left empty for simplicity. If the returned file name string is not empty(the user selected file) we open and read it with <code>std::ifstream</code> and set the text to display in editor with function <code>wxStyledTextCtrl::SetText()</code>. Furthermore, we set the member <code>std::string</code> variable <code>fileName</code> to the file name of opened file. We will use this variable to implement file saving. So, here is <code>OnSave()</code> event handler:</p>
<div>
  <pre><code class='cpp'>void Frame::OnSave(wxCommandEvent&amp; event)
{
        if(fileName.length()&lt;=0)
        {
            wxString p = wxSaveFileSelector(&quot;&quot;, &quot;All Files|*.*|C++ Source Files (*.cpp) |*.cpp| C/C++ Header Files (*.h) |*.h&quot;, &quot;new&quot;);
            if(p!=wxEmptyString)
            {
                fileName = p;
            }
        }
        ofstream of(fileName.c_str());
        of.write(editor-&gt;GetText(),editor-&gt;GetLength());
        of.close();
}</code></pre>
</div>
<p>The <code>wxSaveFileSelector()</code> function shows a save file dialog to the user if the <code>fileName</code> is not set. Here we use the wildcard to give the user option to chose file extension.</p>

<p>The last part of tutorial is <code>GDI</code> (Graphics Device Interface) of <code>wxWidgets</code> library. In this part we will create a simple paint program. So let&#8217;s add one more tab to our notebook and a private member pointer to wxWindow in our <code>Frame</code> class. To do drawing in <code>wxWidgets</code>, we need a device context, which is encapsulated in <code>wxPaintDC</code> class. The <code>wxPaintDC</code> class has various methods to draw lines, points, rectangles, text , circles and bitmaps. When window is moved to another position, we need to redraw our graphics. That is why the <code>EVT_PAINT</code> event exists. However, this event triggers only when the window needs to be redrawn but not when we need to redraw it. To have more frequent updates we can use the special <code>EVT_IDLE</code> event macro. This event triggers all the time when the window becomes idle. This way we can capture input and draw quite frequently. Using the paint program we will write it is possible to draw arbitary lines and change background color. Every line consists of two points. To store points I declared such a structure:</p>
<div>
  <pre><code class='cpp'>struct Point
{
    Point(int _x, int _y, wxColour c, int w) : x(_x), y(_y),color(c), width(w) {}
    int x;
    int y;
    int width;
    wxColour color;
};</code></pre>
</div>
<p>The width member specifies the width of line to be drawn from this point and the color specifies the color of the line to be drawn. We also should add some members to our <code>Frame</code> class: <div>
  <pre><code class='cpp'>std::vector&lt;Point&gt; points;
    wxColour pointColor, bgColor, prevBgColor;
    int lineWidth;
    bool wasReleased;</code></pre>
</div></p>

<p>The points is an array of points to be drawn. The <code>pointColo</code>r and <code>bgColor</code> are used to store the currently selected line color and background color. However, we do not need to redraw background color every time. We will do this only when the <code>bgColor</code> is changed. That is why the <code>prevBgColor</code> member is declared. If <code>bgColor != prevBgColor</code>, we will draw a rectangle of color <code>bgColo</code>r and set <code>prevBgColor</code> to <code>bgColor</code>. The <code>wasReleased</code> indicates whether the user released left mouse button. If so, we have to insert special point with coordinates <code>(-1;-1)</code>, which will not be skipped in our drawing function. Having these bits together, here is the drawing code:</p>
<div>
  <pre><code class='cpp'>void Frame::Redraw(wxDC &amp;dc)
{
    if(bgColor!=prevBgColor)
    {
        dc.SetBrush(wxBrush(bgColor));
        dc.DrawRectangle(0,0,gdiExample-&gt;GetSize().x,gdiExample-&gt;GetSize().y);
        prevBgColor = bgColor;
    }
    for(int i = 0;i&lt;points.size();i++) //draw our points
    {
        dc.SetPen(wxPen(points[i].color,points[i].width,wxPENSTYLE_SOLID));
        if((points[i].x==-1&amp;&amp;points[i].y==-1)||points[i&gt;0?i-1:0].x==-1&amp;&amp;points[i&gt;0?i-1:0].y==-1) //check if there are magic values which indicate the line break
            continue;
        dc.DrawLine(wxCoord(points[i&gt;0?i-1:0].x),wxCoord(points[i&gt;0?i-1:0].y),wxCoord(points[i].x),wxCoord(points[i].y));
    }
}</code></pre>
</div>
<p>The <code>Redraw()</code> function takes as parameter a <code>wxDC</code> object which is the base class for <code>wxPaintDC</code> and other device context objects. I will tell you the reason for this later. To draw a rectangle(background color) we need to specify a brush to use. The we set a pen object to draw lines. We loop through our points array and draw the lines between the current and previous point. If we encounter a special point with coordinates <code>(-1;-1)</code>, we skip the current point to create a line break. At this point it is time to write code for capturing user input.The <code>GetInput()</code> is an idle event handler which creates points if user is pressing left mouse button and calls <code>Redraw()</code> function:</p>
<div>
  <pre><code class='cpp'>void Frame::GetInput(wxIdleEvent&amp; event)
{
    wxMouseState state = wxGetMouseState();
    if(notebook-&gt;GetSelection()==1)
        if(state.LeftIsDown())
            {
                int cx,cy;
                cx = gdiExample-&gt;GetScreenPosition().x;
                cy = gdiExample-&gt;GetScreenPosition().y;
                points.push_back(Point(state.GetX()-cx,state.GetY()-cy,pointColor, lineWidth));
                wasReleased = false;
            }
            else
            {
                if(!wasReleased)
                {
                    points.push_back(Point(-1,-1,pointColor,lineWidth));
                    wasReleased = true;
                }
            }
    wxPaintDC dc(gdiExample);
    Redraw(dc);
}</code></pre>
</div>
<p>We retrieve current <code>wxMouseState</code> object with <code>wxGetMouseState()</code> function. Then we can check whether left mouse button is pressed with <code>wxMouseState::LeftIsDown()</code> method. We than add a point at coordinates of mouse pointer. However, <code>wxMouseState::GetX()</code> and <code>wxMouseState::GetY()</code> return the screen space pointer coordinates. We need to add the position of <code>gdiExample</code> window to get the coordinates locally to the top left corner of window in which we draw. If mouse button is not pressed and the special point <code>(-1;-1)</code> has not been inserted yet(which is indicated by <code>wasReleased</code> variable) we insert it. Finally, we create <code>wxPaintDC</code> object for our gdiExample window and pass it to the <code>Redraw()</code> function.</p>

<p>The last piece of our mosaic is to implement image saving. I showed the definition of <code>OnSave()</code> event handler earlier when we were dealing with text editor. And here is now its modified version. If the pain tab is selected, we save the image, otherwise we save a text file:</p>
<div>
  <pre><code class='cpp'>void Frame::OnSave(wxCommandEvent&amp; event)
{
    if(notebook-&gt;GetSelection()==1) //our simple paint program
    {
        wxMemoryDC memDC; //create memore dc into which we will draw our image
        wxBitmap image(gdiExample-&gt;GetSize().x,gdiExample-&gt;GetSize().y); //create bitmap on which the image will be drawn
        memDC.SelectObject(image); //set the bitmap to be drawn
        memDC.Clear();
        //redraw with updating background color
        memDC.SetBrush(wxBrush(bgColor));
        memDC.DrawRectangle(0,0,gdiExample-&gt;GetSize().x,gdiExample-&gt;GetSize().y);
        Redraw(memDC); //actually draw our image to memory
        memDC.SelectObject(wxNullBitmap); //free the bitmap
        wxString p = wxSaveFileSelector(&quot;&quot;, &quot;PNG Image|*.png|BMP Image|*.bmp|JPEG Image|*.jpg&quot;, &quot;image&quot;);
        if(p!=wxEmptyString)

        {
            wxString path,name,extension;
            wxSplitPath(p,&amp;path,&amp;name,&amp;extension);
            if(extension==&quot;jpg&quot;)
                image.SaveFile(p,wxBITMAP_TYPE_JPEG,NULL);
            if(extension==&quot;png&quot;)
                image.SaveFile(p,wxBITMAP_TYPE_PNG,NULL);
            if(extension==&quot;bmp&quot;)
                image.SaveFile(p, wxBITMAP_TYPE_BMP,NULL);
        }


    }
    if(notebook-&gt;GetSelection()==2) //we are in editor tab
    {
        if(fileName.length()&lt;=0)
        {
            wxString p = wxSaveFileSelector(&quot;&quot;, &quot;All Files|*.*|C++ Source Files (*.cpp) |*.cpp| C/C++ Header Files (*.h) |*.h&quot;, &quot;new&quot;);
            if(p!=wxEmptyString)
            {
                fileName = p;
            }
        }
        ofstream of(fileName.c_str());
        of.write(editor-&gt;GetText(),editor-&gt;GetLength());
        of.close();
    }
}</code></pre>
</div>
<p>The <code>wxNotebook::GetSelection()</code> returns the index of currently selected tab. In this piece of code it is assumed that the paint tab is the second and the editor tab it the third tab from the left. We than create special <code>wxMemoryDC</code> object which features drawing into a <code>wxBitmap</code> object. We redraw the background and call our <code>Redraw()</code> function to draw our points into <code>memDC</code>. Eventually, we save the bitmap in <code>JPEG</code>, <code>PNG</code> or <code>BMP</code> format.</p>

<p><img alt='Our paint program in action' src='/public/wxwidgets-tutorial/paint-shot.png' /></p>

<h2 id='conclusion'>Conclusion</h2>

<p>This is the finish. At this point you are able to create nice applications with a help of <code>wxWidgets</code> library. However, there are a lot of things which I haven&#8217;t covered in this tutorial. Just explore the documentation and Wiki to find out more. For example, <code>wxWidgets</code> features rendering with <code>OpenGL</code> to one of it&#8217;s controls. Furthermore, you can render <code>HTML</code> documents very simply with a help of <code>wxHTMLWindow</code>. Experiment with those things and gain the experience. Good luck!</p>
</article>

<aside class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/opengl-learning-resources.html">
            OpenGL learning resources
            <small><time datetime="2014-10-28T00:00:00+02:00">28 Oct 2014</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/pxg-engine-design.html">
            My own game engine or why I have given up writing it
            <small><time datetime="2014-10-21T00:00:00+03:00">21 Oct 2014</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/brainfuck-programming.html">
            Brainfuck programming
            <small><time datetime="2014-09-28T00:00:00+03:00">28 Sep 2014</time></small>
          </a>
        </h3>
      </li>
    
  </ul>
</aside>


<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'rostakagmfun'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
