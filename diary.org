#+TITLE: RostakaGmfun's diary
#+AUTHOR: Rostyslav Kurylo
#+EMAIL: rostawesomegd@gmail.com
#+options: num:nil toc:t ^:{}

/Some notes on my daily software development adventures./

** GCC stack protector in Nix
:PROPERTIES:
:CUSTOM_ID: gcc-stack-protector
:END:
The stack protection feature of C compiler allows to detect stack buffer overflows (either accidental or intentional)
by placing a magic value at the top of the function stack frame. Just before returning from the function, the magic value is checked,
and in case it has changed, the program aborts.
The ~-f-stack-protector~ GCC option will enable the stack protection for all functions which etiher allocate buffer larger
than 8 bytes on stack (the number of bytes is configurable), or call the ~alloca()~ function.

I run into a problem with this feature while developing my x86_64 OS, since I am not linking to any libraries
(e.g. libstdc, libgcc, and libssp, which is a Stack Smashing Protection implementation by GCC),
but the stack protection feature is enabled by default in Nix gcc package. As a result, I got undefined reference to the ~__stack_chk_fail()~ function.

It is, however, possible to control [[https://nixos.org/nixpkgs/manual/#sec-hardening-in-nixpkgs][hardening in Nixpkgs]] with ~hardeningDisable~ / ~hardeningEnable~
parameters in ~stdenv.mkDerivation~ function.

This worked for me:
#+BEGIN_SRC nix
    hardeningDisable = ["stackprotector"];
#+END_SRC

** Underscores in org-mode
:PROPERTIES:
:CUSTOM_ID: underscores-org-mode
:END:
I had a trouble with making `x86_64` correctly exported from org-mode to HTML.
The issue was caused by Org exporting characters after the underscore as subscript line.
Fortunately, there is an export option `^:` which allows to toggle Tex-like subscript/superscript syntax.
More info here: http://orgmode.org/manual/Export-settings.html, half way down the page.
** PCI overview
:PROPERTIES:
:CUSTOM_ID: pci-overview
:END:
PCI is a widespread bus protocol for peripheral interconnection usually found on x86 platforms
(although originally designed with cross-platformness in mind).
It is quite outdated but I decided to go over it in detail in order to implement a driver for my x86_64 OS
and then possibly move to the PCIe which is a bit more complicated.
Below is a short summary of what I have learned so far:
 - PCI devices are organized into a tree: there are up to 256 buses with up to 32 devices on each bus.
 - The PCI device can be controlled via the /Configuration space/. On x86 platform it can be accessed through the two 32-bit I/O ports.
   The first one contains the offset within the Confiuration space and the second one contains the data to be read or written.
 - On the conventional PCI the size of Configuration space can be as large as 256 bytes, 16 of them (first 4 32-bit registers) are mandatory.
 - Each PCI device is uniquely identified by its DeviceID, VendorID, Class code, and Subclass code.
 - The rest of registers are device-dependent. Among them: Base Address Registers (BARs) contain memory spaces
   and/or I/O port spaces which serve as a comunication channels to the PCI device.
 - The Capabilities pointer is an 4-byte aligned 8-bit address of first entry in the linked list of device /capabilities/ located at the
   tail of Configuration space.
 - Each entry in capability list contains at least 2 bytes: capability id and /next/ pointer (offset in configuration space).
   The rest is device-specific data.
** Multibyte transfer over I^{2}C bus
:PROPERTIES:
:CUSTOM_ID: multibyte-i2c-transfer
:END:
I^{2}C bus is a common hardware protocol to communicate with multiple low-speed peripherals located tightly on the board.
I^{2}C is used mostly in the embedded devices
(one exception known to me is I^{2}C-compatible modification called SMBus,
which is frequently used in laptop and desktop computers to communicate with power management subsystems).
That is why performance considerations are common when talking about I^{2}C-enabled peripherals,
especially about those that consume or produce lots of data (like different kinds of sensors).
A minimal unidirectional one-byte transfer of I^{2}C communication looks like this:

1. Master sends a START condition bit.
2. Master sends a 7-bit (or 10-bit) slave address.
3. Master sends a R/W bit.
4. Slave sends ACK
5. Master transfers or accepts an 8-bit packet of data to or form the requested slave.
6. If the transfer was master-to-slave, the slave sends ACK bit, otherwise the master sends NACK bit.
7. Master sends a STOP condition bit.

The number of bits sent is 20 (for 7-bit salve address), so the total overhead to send one byte is 12 bits.

It is a common case for the master to first write a request (e.g register address) and then accept the reply from the slave.
This is possible by sending the /repeated START condition/ just after the step 4.
The repeated START condition is then followed by steps 2-6 resulting in 11 bits overhead per data byte.
This way, the total overhead to transfer N bytes this way is ~(1+7+1+1)*N+1~ bits or ~11*N+1~ (for 7-bit slave address).

A good feature of I^{2}C is to transfer multiple (unlimited!) number of bytes without going through the sequence of steps 2-6
to transfer every byte. This requires some support from the slave, though. The communication will look like this:

1. Master sends a START condition bit.
2. Master sends a 7-bit (or 10-bit) slave address.
3. Master sends a R/W bit.
4. Slave sends ACK.
5. Master sends repeated START condition bit.
5. Master transfers or accepts a variable number of 8-bit packets of data to or from the requested slave.
   The number of packets is specified by slave depending on its state.
   For each transferred byte, a single ACK bit is required from master or slave depending on the transfer direction.
7. Master sends a STOP condition bit.

In this case, the overhead is only ~1+7+1+1+N+1~ bits or ~11+N~ bits per byte (for 7-bit slave address).

As a consequence, to transfer e.g. 32 bytes from the sensor, you will save ~(11*32+1)-(11+32) = 310~ bits, which is about 38 bytes
(even more than you actually intended to transfer!).

Another great advantage of multi-byte transfer is that it can be issued with the single DMA transaction, which causes more
efficient utilization of the DMA and gives the CPU more time either do more work or to save more power.
** Verifying Multiboot header with grub-file
:PROPERTIES:
:CUSTOM_ID: verifying-multiboot-header
:END:
As I started doing some bare-metal x86_64 development, I found out a useful tool to verify
if the GRUB multiboot header is correct. The ~grub-file~ command (In my case, the ~grub2~ package from NixOS channel)
accepts the executable and returns if it is correct via the exit code, which is is handy to use in automated builds:
#+BEGIN_SRC bash
grub-file --is-x86-multiboot my_kernel
#+END_SRC
** Trying out NixOps
:PROPERTIES:
:CUSTOM_ID: using-nixops
:END:
I wanted to try out [[https://nixos.org/NixOps][NixOps]] for long time and, finally, I've found some free time to play with it.
NixOps is an IaC (Infrastructure as Code) tool based on Nix, a purely functional package manager,
which I have been using together with [[https://nixos.org/NixOs][NixOs]] Linux distribution for about two months.

Interestingly, this is a first time I've tried to use IaaC tools,
and I believe it is a good thing to go functional from the beginning :)
What I have done with NixOps so far, is a VirtualBox server with a NixOS container running Apache server with `Hello, world` page.

What is good about functional approach to infrastructure it the precise reproducibility of deployment
thanks to purity of Nix expressions.
An /expression/, a pure function in Nix, declaratively defines a software package
or the entire environment, which consits of multiple packages and system configurations.
Since the expressions are pure, the global state of the system is never mutated, which means that
it is impossible (well, in theory) to introduce broken states while redeploying with Nix.

** Benchmarking my kv storage with google/benchmark
:PROPERTIES:
:CUSTOM_ID: benchmarking
:END:
As I am learning about persistent key-value storages,
I decided to implement simple storage on my own in order to apply knowledge I have acquired.

I planned to go with simplest ever persistent key-value storage and improve it iteratively
by employing smart techniques I discover in some articles and /Designing Data-Intensive Applications/ book.

In order to measure my progress, I started writing benchmarks using the [[https://github.com/google/benchmark][google/benchmark]] library,
a feature-rich benchmarking framework for C++.

** Key-value storages, bloom filter and cuckoo hashing
:PROPERTIES:
:CUSTOM_ID: bloom-filters-cuckoo-hashing
:END:
I have been learning about design and architecture of persistent key-value storages for a few days,
and today I started reading a paper on [[http://www.vldb.org/pvldb/vldb2010/papers/I04.pdf][FlashStore]].
As I read through it, I had to google some info about /bloom filters/ and /cuckoo hashing/.

A few notes on bloom filter:

- Bloom filter is a probabilistic data structure that implements a ~Set~ abstract data type.
- Probabilistic means that operations on the DS don't give correct results all the time.
- Supports ~add~ and ~test~ operations with constant time complexity. ~delete~ is not supported in classic implementation (TODO: investigate).
- ~test~ deterministically answers if the element is not present in the set but may emit false positives.
- Bloom filters are implemented as a bitmap and a number of hash functions, which produce bit positions.
- ~add~ hashes the value with each hash function and sets corresponding bits to 1.
- To check if an element exists in a set, it is hashed and corresponding bits are compared.
- The smaller is the load factor, the smaller is the probability of false positives.
- Applications: quickly check if some data is present on slow storage to avoid reading from it.
- [[https://www.jasondavies.com/bloomfilter/][Visualization]].

A bit on cuckoo hashing:

- Implements dictionary abstract data type with worst-case constant time for lookup (compare to traditional hash tables (open addressing/chaining) with linear worst-case lookup).
- Cuckoo hashing is implemented as two hash tables with independent hash functions thus providing two places where new element can be inserted.
- Collision occurs when both places are occupated.
- The collision is resolved with placing the other value at another hash table, hence the name cuckoo: new-born cuckoo birds throw their sibling eggs from the nest (I hadn't known this before!).
- The process of moving elements lasts until a free cell is found or a loop is detected. In the latter case the table is rehashed.
** First day using org-mode
:PROPERTIES:
:CUSTOM_ID: hello-org
:END:
So I decided to maintain a list of tiny notes on programming-related topics, and because I have started using Emacs a few weeks ago, I took up org-mode for this.

Traditional blogging takes much time and skill and so I consider maintaining such a diary a perfect solution if you lack on of these (or both, as I do).

Furthermore, as a side profit, summarizing improves learning productivity.
