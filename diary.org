#+TITLE: RostakaGmfun's diary
#+AUTHOR: Rostyslav Kurylo
#+EMAIL: rostawesomegd@gmail.com
#+options: num:nil toc:t

/Some notes on my daily software development adventures./

** Mutlibyte transfer over I^{2}C bus
:PROPERTIES:
:CUSTOM_ID: multibyte-i2c-transfer
:END:
I^{2}C bus is a common hardware protocol to communicate with multiple low-speed peripherals located tightly on the board.
I^{2}C is used mostly in the embedded devices
(one exception known to me is I^{2}C-compatible modification called SMBus,
which is frequently used in laptop and desktop computers to communicate with power management subsystems).
That is why performance considerations are common when talking about I^{2}C-enabled peripherals,
especially about those that consume or produce lots of data (like different kinds of sensors).
A minimal unidirectional one-byte transfer of I^{2}C communication looks like this:

1. Master sends a START condition bit.
2. Master sends a 7-bit (or 10-bit) slave address.
3. Master sends a R/W bit.
4. Slave sends ACK
5. Master transfers or accepts an 8-bit packet of data to or form the requested slave.
6. If the transfer was master-to-slave, the slave sends ACK bit, otherwise the master sends NACK bit.
7. Master sends a STOP condition bit.

The number of bits sent is 20 (for 7-bit salve address), so the total overhead to send one byte is 12 bits.

It is a common case for the master to first write a request (e.g register address) and then accept the reply from the slave.
This is possible by sending the /repeated START condition/ just after the step 4.
The repeated START condition is then followed by steps 2-6 resulting in 11 bits overhead per data byte.
This way, the total overhead to transfer N bytes this way is ~(1+7+1+1)*N+1~ bits or ~11*N+1~ (for 7-bit slave address).

A good feature of I^{2}C is to transfer multiple (unlimited!) number of bytes without going through the sequence of steps 2-6
to transfer every byte. This requires some support from the slave, though. The communication will look like this:

1. Master sends a START condition bit.
2. Master sends a 7-bit (or 10-bit) slave address.
3. Master sends a R/W bit.
4. Slave sends ACK.
5. Master sends repeated START condition bit.
5. Master transfers or accepts a variable number of 8-bit packets of data to or from the requested slave.
   The number of packets is specified by slave depending on its state.
   For each transferred byte, a single ACK bit is required from master or slave depending on the transfer direction.
7. Master sends a STOP condition bit.

In this case, the overhead is only ~1+7+1+1+N+1~ bits or ~11+N~ bits per byte (for 7-bit slave address).

As a consequence, to transfer e.g. 32 bytes from the sensor, you will save ~(11*32+1)-(11+32) = 310~ bits, which is about 38 bytes
(even more than you actually intended to transfer!).

Another great advantage of multi-byte transfer is that it can be issued with the single DMA transaction, which causes more
efficient utilization of the DMA and gives the CPU more time either do more work or to save more power.
** Verifying Multiboot header with grub-file
:PROPERTIES:
:CUSTOM_ID: verifying-multiboot-header
:END:
As I started doing some bare-metal x86_64 development, I found out a useful tool to verify
if the GRUB multiboot header is correct. The ~grub-file~ command (In my case, the ~grub2~ package from NixOS channel)
accepts the executable and returns if it is correct via the exit code, which is is handy to use in automated builds:
#+BEGIN_SRC bash
grub-file --is-x86-multiboot my_kernel
#+END_SRC
** Trying out NixOps
:PROPERTIES:
:CUSTOM_ID: using-nixops
:END:
I wanted to try out [[https://nixos.org/NixOps][NixOps]] for long time and, finally, I've found some free time to play with it.
NixOps is an IaC (Infrastructure as Code) tool based on Nix, a purely functional package manager,
which I have been using together with [[https://nixos.org/NixOs][NixOs]] Linux distribution for about two months.

Interestingly, this is a first time I've tried to use IaaC tools,
and I believe it is a good thing to go functional from the beginning :)
What I have done with NixOps so far, is a VirtualBox server with a NixOS container running Apache server with `Hello, world` page.

What is good about functional approach to infrastructure it the precise reproducibility of deployment
thanks to purity of Nix expressions.
An /expression/, a pure function in Nix, declaratively defines a software package
or the entire environment, which consits of multiple packages and system configurations.
Since the expressions are pure, the global state of the system is never mutated, which means that
it is impossible (well, in theory) to introduce broken states while redeploying with Nix.

** Benchmarking my kv storage with google/benchmark
:PROPERTIES:
:CUSTOM_ID: benchmarking
:END:
As I am learning about persistent key-value storages,
I decided to implement simple storage on my own in order to apply knowledge I have acquired.

I planned to go with simplest ever persistent key-value storage and improve it iteratively
by employing smart techniques I discover in some articles and /Designing Data-Intensive Applications/ book.

In order to measure my progress, I started writing benchmarks using the [[https://github.com/google/benchmark][google/benchmark]] library,
a feature-rich benchmarking framework for C++.

** Key-value storages, bloom filter and cuckoo hashing
:PROPERTIES:
:CUSTOM_ID: bloom-filters-cuckoo-hashing
:END:
I have been learning about design and architecture of persistent key-value storages for a few days,
and today I started reading a paper on [[http://www.vldb.org/pvldb/vldb2010/papers/I04.pdf][FlashStore]].
As I read through it, I had to google some info about /bloom filters/ and /cuckoo hashing/.

A few notes on bloom filter:

- Bloom filter is a probabilistic data structure that implements a ~Set~ abstract data type.
- Probabilistic means that operations on the DS don't give correct results all the time.
- Supports ~add~ and ~test~ operations with constant time complexity. ~delete~ is not supported in classic implementation (TODO: investigate).
- ~test~ deterministically answers if the element is not present in the set but may emit false positives.
- Bloom filters are implemented as a bitmap and a number of hash functions, which produce bit positions.
- ~add~ hashes the value with each hash function and sets corresponding bits to 1.
- To check if an element exists in a set, it is hashed and corresponding bits are compared.
- The smaller is the load factor, the smaller is the probability of false positives.
- Applications: quickly check if some data is present on slow storage to avoid reading from it.
- [[https://www.jasondavies.com/bloomfilter/][Visualization]].

A bit on cuckoo hashing:

- Implements dictionary abstract data type with worst-case constant time for lookup (compare to traditional hash tables (open addressing/chaining) with linear worst-case lookup).
- Cuckoo hashing is implemented as two hash tables with independent hash functions thus providing two places where new element can be inserted.
- Collision occurs when both places are occupated.
- The collision is resolved with placing the other value at another hash table, hence the name cuckoo: new-born cuckoo birds throw their sibling eggs from the nest (I hadn't known this before!).
- The process of moving elements lasts until a free cell is found or a loop is detected. In the latter case the table is rehashed.
** First day using org-mode
:PROPERTIES:
:CUSTOM_ID: hello-org
:END:
So I decided to maintain a list of tiny notes on programming-related topics, and because I have started using Emacs a few weeks ago, I took up org-mode for this.

Traditional blogging takes much time and skill and so I consider maintaining such a diary a perfect solution if you lack on of these (or both, as I do).

Furthermore, as a side profit, summarizing improves learning productivity.
